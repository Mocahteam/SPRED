\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage[a4paper]{geometry}

\title{Editeur de niveaux\\Prog \& Play}
\author{Benjamin BONTEMPS}

\sloppy

\begin{document}

\maketitle

\begin{abstract}
Ce document a pour objectifs de récapituler l'essentiel du travail réalisé dans le cadre du projet de conception d'un éditeur de niveaux pour le jeu sérieux Prog\&Play et de permettre sa maintenabilité en cas de nécessité. Il suppose acquis les concepts de base liés à Prog\&Play, à Spring (moteur sur lequel est basé le jeu) et au développement en Lua.
\end{abstract}

\tableofcontents

\newpage

\section{Architecture globale}
\paragraph{}
Cette section présente les choix effectués quant à l'architecture adoptée pour la réalisation de l'éditeur de niveaux.
\paragraph{}
Le pré-launcher est composé d'un unique widget (launcher.lua) permettant de sélectionner le jeu de base sur lequel les niveaux vont être créés.
\paragraph{}
Le launcher est composé d'un widget central permettant d'afficher l'interface du launcher et de réagir en fonction des boutons sur lesquels l'utilisateur clique (editor\_spring\_direct\_launch.lua). A noter que ce widget communique également avec les autres widgets et gadgets définis ci-dessous.
\paragraph{}
L'éditeur à proprement parler est composé de :
\begin{itemize}
\item Un widget central permettant d'afficher les éléments de l'interface utilisateur et de capter les interactions avec cette dernière ou avec le moteur pour effectuer des actions en conséquence. (editor\_user\_interface.lua)
\item Un widget permettant de récupérer la liste des commandes que les différentes unités du jeu sélectionné dans le pré-launcher peuvent exécuter. (editor\_commands\_list.lua)
\item Un widget permettant de récupérer la liste de tous les widgets présents. (editor\_widget\_list.lua)
\item Un widget affichant un écran de chargement pour empêcher l'utilisateur d'interagir avec l'interface lorsqu'elle n'est pas complètement chargée (editor\_loading\_screen.lua)
\item Un widget permettant de ne pas afficher les boutons permettant de donner des ordres aux unités. (hide\_commands.lua)
\item Un gadget permettant l'utilisation de code synchronisé\footnote{Par exemple, la création d'une unité sur le terrain.}. (editor\_gadget.lua)
\item Deux fichiers contenant toutes les chaînes de caractères à afficher. (EditorStrings.lua et LauncherStrings.lua)
\item Un fichier définissant une classe\footnote{Au sens de Lua.} machine à états. (StateMachine.lua)
\item Un fichier contenant des fonctions utilitaires. (Misc.lua)
\item Des fichiers de description de tables Lua. (Actions.lua, Conditions.lua, TextColors.lua)
\end{itemize}
\paragraph{}
Ces modules dépendent pour la plupart des bibliothèques suivantes :
\begin{itemize}
\item \textbf{Chili UI} - Framework d'interface graphique
\item \textbf{dkjson.lua} - Permet de convertir une table lua en string au format json et inversement.
\item \textbf{xml-serde.lua} - Permet de convertir une table lua possédant une syntaxe spécifique en string au format xml et inversement.
\item \textbf{RestartScript.lua} - Permet de redémarrer le jeu avec certains paramètres supplémentaires.
\end{itemize}
\section{Chili UI}
\paragraph{}
Afin de simplifier le développement de l'interface graphique, j'ai choisi d'utiliser un framework d'interface graphique développé spécifiquement pour Spring dénommé Chili UI. 
\paragraph{}
Ce framework a l'avantage de ne pas avoir à utiliser l'API OpenGL de Spring et les différents listeners pour afficher et permettre l'interaction avec des fenêtres, boutons etc. Tout y est déjà implémenté, ce qui a permis de réduire considérablement le temps requis pour obtenir les premiers résultats. Le problème majeur est que le framework est extrêmement mal documenté, et la meilleure façon de comprendre son fonctionnement pour s'en servir correctement voire même le modifier pour l'adapter à des besoins particuliers est de se référer au code source présent sur github\footnote{https://github.com/jk3064/chiliui/}.
\paragraph{}
Les modifications que j'y ai personnellement apporté concernent les boutons, qui possèdent un état supplémentaire \textit{chosen} permettant d'avoir un feedback visuel lorsqu'on les sélectionne (les modifications de cet état sont gérées "à la main", mais le feedback visuel est géré automatiquement par le framework).
\paragraph{}
Le widget comporte de nombreuses fonctions reprenant les fonctions \textit{New} du framework en n'utilisant qu'un certain nombre de paramètres, ce qui permet une définition plus compacte de chaque élément de l'interface. Le point négatif est qu'il faut soit connaître par cœur l'ordre dans lequel les paramètres doivent être renseignés dans le prototype de la fonction soit se référer en permanence à la définition des fonctions. Ces fonctions sont définies dans la catégorie \textit{Chili UI functions}.
\paragraph{}
Il faut faire extrêmement attention à une chose en particulier en ce qui concerne le framework : il ne faut surtout pas modifier les éléments d'interface qui ne sont pas affichés à l'écran (c'est-à-dire les éléments d'interface qui n'ont ni Screen0, ni un descendant de Screen0 en tant que parent). Ceci ne produit pas d'erreur lors de l'exécution, mais les éléments d'interface concernés ne s'actualiseront plus correctement, ce qui est très gênant d'un point de vue utilisateur (les opérations seront effectuées, mais l'utilisateur n'aura aucun feedback visuel).
\section{Le pré-launcher}
\paragraph{}
Le pré-launcher est la base de l'éditeur. Il permet de sélectionner un jeu de base sur lequel l'utilisateur va ensuite créer ses niveaux. Lorsque le jeu en question est sélectionné, le pré-launcher va s'occuper de créer une archive contenant les fichiers permettant le fonctionnement de l'éditeur tout en y modifiant le fichier ModInfo.lua contenant les informations de dépendance pour y ajouter le jeu sélectionné. Ensuite, il va redémarrer Spring avec l'archive nouvellement créée.
\paragraph{}
Si l'archive correspondant à l'éditeur pour un certain mod est déjà créée, il va simplement redémarrer Spring en utilisant cette archive. Ceci ne pose pas de problèmes d'un point de vue utilisateur, mais pendant une phase de développement, il ne faut pas oublier de supprimer l'archive créée à chaque modification.
\section{Le launcher}
\paragraph{}
La launcher se présente en 3 menus distincts : Création d'un nouveau niveau, Edition d'un niveau existant et Edition d'un scénario. Pendant l'écran de chargement du launcher, le gadget instancie chacune des unités du mod de base, récupère la liste de leurs commandes et la transfère au widget editor\_commands\_list.lua qui effectue un tri dessus. Les commandes seront ensuite passées à l'éditeur grâce au ModOptions.
\subsection{Création d'un nouveau niveau}
\paragraph{}
Rien de très compliqué ici : on s'occupe simplement de lister les cartes présentes dans le répertoire maps/ à la racine de Spring. Lorsque l'utilisateur clique sur le nom d'une carte, Spring redémarre sur la carte sélectionnée.
\subsection{Edition d'un niveau existant}
\paragraph{}
De même, on liste ici les niveaux correspondant au jeu sélectionné qui sont dans le répertoire pp\_editor/missions/. Lorsque l'utilisateur clique sur le nom d'un niveau, on va chercher dans la description de ce niveau la carte sur laquelle le niveau a été créé, puis on redémarre Spring sur la bonne carte et on indique dans le ModOptions que l'éditeur va devoir charger ce niveau.
\subsection{Editeur de scénario}
\paragraph{}
Pour chaque niveau créé correspondant au jeu sélectionné, on créé une fenêtre contenant le nom du niveau, un bouton pour l'état d'entrée et n boutons pour les n états de sortie. En cliquant sur un bouton correspondant à un état de sortie, on stocke dans les variables \textit{selectedOutputMission} et \textit{selectedOutput} l'état de sortie sur lequel on vient de cliquer. Si ces variables ne sont pas nil et que l'on clique sur un état d'entrée, on le stocke dans \textit{selectedInput}.
\paragraph{}
La fonction MakeLink() s'effectue à chaque frame et s'occupe de répertorier un lien dans la table Links si selectedOutputMission, selectedOutput et selectedInput ne sont pas nil. Un objet Chili personnalisé permet d'afficher ces liens lorsqu'ils existent.
\paragraph{}
En ce qui concerne la sauvegarde et le chargement des scénarios, ceci se fait en utilisant la bibliothèque xml-serde qui nous permet de transformer la table Links en fichier xml et vice-versa.
\paragraph{}
Pour l'exportation de l'archive du jeu final, on lit le contenu de la table Links pour définir les niveaux à exporter, puis on créé une archive contenant les fichiers nécessaires au fonctionnement du jeu ainsi que le scénario et les niveaux qui le composent.
\section{L'éditeur de niveaux}
\subsection{Editor User Interface}
\paragraph{}
Ce widget est l'élément central de l'éditeur de niveaux. Le choix d'un widget en tant qu'élément central se justifie par le fait que la majorité des interactions se font de façon asynchrone. L'unicité du widget vient du fait qu'il n'est possible de n'avoir des variables communes à plusieurs widgets qu'en passant par la table WG, ce qui aurait été gênant étant donné le très grand nombre de variables devant être utilisées à de nombreux endroits distincts.
\subsubsection{Initialisation}
\paragraph{}
L'initialisation de la quasi-intégralité de l'interface se fait par les fonctions d'initialisation décrites dans la catégorie \textit{Initialisation functions}. La grande majorité des fenêtres y est initialisée, en les affichant toutes d'un coup (pour les raisons évoquées précédemment), puis elles sont ensuite masquées pour n'afficher que la fenêtre correspondant à l'état actuel de la machine à états globale (voir \ref{statemachine}).
\paragraph{}
Sont présentes également deux fonctions s'occupant de l'initialisation de fonctions liées aux changements d'état lors de la sélection d'un type et d'une équipe d'une unité pour la placer ensuite sur le terrain.
\paragraph{}
Les fonctions des catégories \textit{Top bar functions} et \textit{Forces window buttons functions} s'occupent de changer l'état courant de la machine à états globale et de choisir quelles fenêtres doivent être affichées. Il s'agit pour la plupart de fonctions appelées lors de la pression sur des boutons ou sur des touches du clavier.
\subsubsection{Unités et groupes d'unités}
\paragraph{}
Les fonctions présentes dans la section \textit{Unit/Selection state functions} gèrent à la  fois le placement des unités (choix du type et de l'équipe), la sélection, le positionnement, l'orientation, les attributs et l'appartenance à un groupe d'une ou plusieurs unités.
\paragraph{} Les états de la machine à états des unités permettent d'adapter le comportement des fonctions listeners d'évènements souris ou clavier. Ainsi, les fonctionnalités de sélection, rotation, déplacement... des unités se font dans les fonctions de callback des événements souris.
\subsubsection{Zones}
\paragraph{}
Les fonctions de cette section concernent la création, suppression, affichage, sélection et déplacement des zones logiques. Ces zones sont utilisées dans les déclencheurs.
\paragraph{}
De même que précédemment, les états de la machine à états régissent les interactions souris, qui sont donc gérées dans les listeners du widget.
\subsubsection{Forces}
\paragraph{}
Les fonctions de cette section s'occupent d'afficher les paramètres liés aux équipes et de gérer les alliances entre les différentes équipes actives.
\subsubsection{Déclencheurs}
\paragraph{}
Les fonctions de cette partie concernent la gestion du système de déclencheurs (création, édition, suppression des évènements, conditions et actions ainsi que la gestion des variables).
\subsubsection{Paramètres de la carte}
\subsubsection{Entrées / Sorties}
\subsubsection{Fonctions de dessin}
\subsubsection{Listeners\label{listeners}}
\subsection{Gadget}
\subsection{Machines à états\label{statemachine}}
\subsection{Fonctions utilitaires}
\subsection{Fichiers de description}
\end{document}
